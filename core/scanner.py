# scanner.py
"""
Module qu√©t h·ªá th·ªëng t√¨m r√°c cho CleanerApp.
T·ªëi ∆∞u h√≥a hi·ªáu su·∫•t b·∫±ng ƒëa lu·ªìng v√† gi·ªõi h·∫°n ƒë·ªô s√¢u qu√©t.
"""

import os
from pathlib import Path
from collections import defaultdict
from datetime import datetime
from time import time
from typing import List, Tuple
from concurrent.futures import ThreadPoolExecutor

from core.rules import (
    get_scan_directories,
    is_empty_directory,
    is_garbage_file,
    can_delete,
    check_permissions,
    get_grouping_root,
    get_garbage_type,
    detect_installed_browsers,
    GARBAGE_TYPES
)
from utils import is_file_locked


class TrashScanner:
    """
    L·ªõp ch·ªãu tr√°ch nhi·ªám qu√©t h·ªá th·ªëng ƒë·ªÉ ph√°t hi·ªán file/th∆∞ m·ª•c r√°c.

    T√≠nh nƒÉng:
    - Duy·ªát th∆∞ m·ª•c b·∫±ng ƒëa lu·ªìng
    - Ph√¢n lo·∫°i th√†nh 12 nh√≥m r√°c chu·∫©n
    - Gi·ªõi h·∫°n ƒë·ªô s√¢u ƒë·ªÉ tr√°nh qu√©t s√¢u g√¢y ch·∫≠m
    - Ghi log v√† th·ªëng k√™ chi ti·∫øt sau khi qu√©t
    """

    def __init__(self):
        """
        Kh·ªüi t·∫°o c√°c bi·∫øn l∆∞u k·∫øt qu·∫£:
        - trash_paths: Danh s√°ch path r√°c ƒë√£ x√°c ƒë·ªãnh
        - total_size: T·ªïng dung l∆∞·ª£ng r√°c
        - rejected_paths: Danh s√°ch kh√¥ng th·ªÉ x√≥a
        - classified_paths: Gom r√°c theo lo·∫°i
        - installed_browsers: Tr√¨nh duy·ªát ƒë∆∞·ª£c c√†i
        - scan_duration: Th·ªùi gian qu√©t th·ª±c t·∫ø
        """
        self.trash_paths: List[Path] = []
        self.total_size: int = 0
        self.rejected_paths: List[Tuple[Path, dict]] = []
        self.classified_paths: dict[str, List[Path]] = defaultdict(list)
        self.installed_browsers = detect_installed_browsers()
        self.scan_duration = 0

    def scan_garbage(self) -> Tuple[List[Path], int]:
        """
        Ti·∫øn h√†nh qu√©t h·ªá th·ªëng s·ª≠ d·ª•ng ƒëa lu·ªìng ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô.

        Returns:
            Tuple[List[Path], int]: Danh s√°ch file/th∆∞ m·ª•c r√°c v√† t·ªïng dung l∆∞·ª£ng.
        """
        start = time()
        scan_dirs = get_scan_directories()
        with ThreadPoolExecutor(max_workers=8) as executor:
            executor.map(self._scan_directory, scan_dirs)
        self.scan_duration = time() - start
        return self.trash_paths, self.total_size

    def _scan_directory(self, root: Path, max_depth: int = 6) -> None:
        """
        ƒê·ªá quy duy·ªát th∆∞ m·ª•c ƒë·ªÉ ki·ªÉm tra file/th∆∞ m·ª•c r√°c trong th∆∞ m·ª•c `root`.

        Args:
            root (Path): Th∆∞ m·ª•c g·ªëc c·∫ßn qu√©t
            max_depth (int): Gi·ªõi h·∫°n chi·ªÅu s√¢u ƒë·ªá quy ƒë·ªÉ tr√°nh qu√° s√¢u
        """
        if not root.exists() or not root.is_dir():
            return

        try:
            for dirpath, dirnames, filenames in os.walk(root):
                rel = Path(dirpath).relative_to(root)
                if len(rel.parts) > max_depth:
                    dirnames[:] = []  # kh√¥ng ƒëi s√¢u h∆°n
                    continue

                # print(f"üìÅ ƒêang qu√©t: {dirpath}")
                current = Path(dirpath)

                for fname in filenames:
                    fpath = current / fname
                    if not is_garbage_file(fpath):
                        continue
                    if not can_delete(fpath) or is_file_locked(fpath):
                        self.rejected_paths.append(
                            (fpath, check_permissions(fpath)))
                        continue
                    self.trash_paths.append(fpath)
                    self.total_size += fpath.stat().st_size
                    gtype = get_garbage_type(fpath, self.installed_browsers)
                    self.classified_paths[gtype].append(fpath)

                for dname in dirnames:
                    dpath = current / dname
                    if is_empty_directory(dpath):
                        if can_delete(dpath):
                            self.trash_paths.append(dpath)
                            gtype = get_garbage_type(
                                dpath, self.installed_browsers)
                            self.classified_paths[gtype].append(dpath)
                        else:
                            self.rejected_paths.append(
                                (dpath, check_permissions(dpath)))
        except Exception:
            pass

    def get_classified_summary(self) -> dict:
        """
        Tr·∫£ v·ªÅ th·ªëng k√™ s·ªë l∆∞·ª£ng v√† dung l∆∞·ª£ng c·ªßa t·ª´ng lo·∫°i r√°c.

        Returns:
            dict: {lo·∫°i_r√°c: (s·ªë l∆∞·ª£ng, t·ªïng_dung_l∆∞·ª£ng)}
        """
        summary = {}
        for rtype, paths in self.classified_paths.items():
            total = 0
            for p in paths:
                try:
                    if p.is_file():
                        total += p.stat().st_size
                except:
                    pass
            summary[rtype] = (len(paths), total)
        return summary

    def export_scan_result(self) -> None:
        """
        Ghi k·∫øt qu·∫£ qu√©t r√°c ra file:
        - scan_summary.txt: t·ªïng k·∫øt
        - chi_tiet_rac/<loai>.txt: chi ti·∫øt t·ª´ng lo·∫°i
        - history.txt: d√≤ng ghi l·ªãch s·ª≠ qu√©t
        """
        scanner_dir = Path("docs/scanner")
        if scanner_dir.exists():
            for file in scanner_dir.glob("**/*"):
                try:
                    file.unlink()
                except:
                    pass

        now = datetime.now()
        time_str = now.strftime("%Y-%m-%d %H:%M:%S")
        summary = self.get_classified_summary()
        os.makedirs("docs/scanner/chi_tiet_rac", exist_ok=True)

        main_log = scanner_dir / "scan_summary.txt"
        with open(main_log, "w", encoding="utf-8") as f:
            f.write(f"Th·ªùi gian ho√†n t·∫•t: {time_str}\n")
            f.write(f"T·ªïng s·ªë file r√°c: {len(self.trash_paths)}\n")
            f.write(f"T·ªïng dung l∆∞·ª£ng: {self.total_size / 1024:.2f} KB\n")
            f.write(f"Th·ªùi gian qu√©t: {self.scan_duration:.2f} gi√¢y\n\n")

            for rtype in GARBAGE_TYPES:
                count, size = summary.get(rtype, (0, 0))
                f.write(f"- {rtype}: {count} m·ª•c, {size / 1024:.2f} KB\n")
                filename = rtype.lower().replace(" ", "_") + ".txt"
                detail_path = scanner_dir / "chi_tiet_rac" / filename
                with open(detail_path, "w", encoding="utf-8") as df:
                    for path in self.classified_paths.get(rtype, []):
                        try:
                            size_kb = path.stat().st_size / 1024 if path.is_file() else 0
                            df.write(f"{path} ({size_kb:.2f} KB)\n")
                        except:
                            df.write(f"{path} (Kh√¥ng l·∫•y ƒë∆∞·ª£c dung l∆∞·ª£ng)\n")

        history_path = Path("docs/history.txt")
        with open(history_path, "a", encoding="utf-8") as hf:
            hf.write(
                f"{time_str} | {len(self.trash_paths)} file | {self.total_size / 1024:.2f} KB\n")


def run_scan():
    """
    H√†m d√πng ƒë·ªÉ ch·∫°y th·ª≠ qu√° tr√¨nh qu√©t:
    - G·ªçi TrashScanner
    - Xu·∫•t k·∫øt qu·∫£
    - In th·ªëng k√™ ra console
    """
    scanner = TrashScanner()
    scanner.scan_garbage()
    scanner.export_scan_result()
    print(f"üîç ƒê√£ qu√©t {len(scanner.trash_paths)} file/th∆∞ m·ª•c r√°c.")
    print(f"üì¶ T·ªïng dung l∆∞·ª£ng: {scanner.total_size / 1024:.2f} KB")
    print(f"üïí Th·ªùi gian qu√©t: {scanner.scan_duration:.2f} gi√¢y")
    print("üìÑ Chi ti·∫øt ƒë√£ l∆∞u trong: docs/scanner/")
